# 计算机网络(小林coding)

**[小林图解网络](https://xiaolincoding.com/network/1_base/tcp_ip_model.html#网络层)**

## 一、基础篇

### 1.1 TCP/IP网络模型有哪几层

**为什么要有TCP/IP网络模型？**

同一台设备的进程间通信有许多方式（管道、消息队列、共享内存、信号等方式），对于不同设备上的进程间通信，就需要网络通信。但设备是多样性的，所以要兼容多种多样的设备，就协商出了一套通用的网络协议。

该网络协议是分层的，每一层都有各自的作用和职责。

#### 1.1.1 应用层

应用层（Applicantion Layer）是最上层的且也是我们最能直接接触到的，电脑、手机的应用软件都是在应用层实现的。两个不同设备的应用需要通信时，就把应用数据传给下一层，即传输层。

应用层只需要专注为用户提供应用功能，比如HTTP、FTP、Telnet、DNS、SMTP等。

应用层工作在操作系统中的用户态，传输层及以下则工作在内核态。

#### 1.1.2 传输层

传输层接收应用层的数据包，为应用层提供网络支持。

两个传输协议：

- TCP：传输控制协议(Transmission Control Protocol)，TCP相比UDP多了很多特性，比如流量控制、超时重传、拥塞控制登，都是为了保证数据包能可靠地传输给对方。
- UDP：只负责发送数据包，但不保证数据包是否能抵达对方，实时性相对更好，传输效率也高。UDP也可以实现可靠传输，只需要把TCP的特性在应用层上实现即可。

应用需要传输的数据可能会非常大，如果直接传输不好控制。要因此但传输层的数据包大小超过MSS(TCP最大报文段长度)，就要将数据包分块，即使中途有一个分块丢失或损坏，也只需要重发这一分块，不用重发整个数据包。在TCP协议中，每一个分块称为TCP段(TCP Segment)。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/TCP%E6%AE%B5.png)

当设备作为接收方时，传输层负责把数据包传给应用，但一台设备可能会有多个应用在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是**端口**。

80端口通常是Web服务器用的，22端口通常是远程登录服务器用的。对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。

由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。

#### 1.1.3 网络层

如果一个设备的数据要传输给另一个设备，就需要在各种各样的路径和节点进行选择，而传输层的设计理念是简单、高效、专注，如果传输层负责这一块功能就违背设计原则了。

网络层承担实际的传输功能。

网络层最常使用的是IP协议(Internet Protocol)，IP协议会将传输层的报文作为数据部分，再加上IP包头组装成IP报文，如果IP报文大小超过MTU（以太网中一般为1500字节）就会再次进行分片，得到一个即将发送到网络的IP报文。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/12.jpg)

网络层负责将数据从一个设备传输到另一个设备，世界上如此多的设备，该如何找到对应设备？因此，网络层需要有区分设备的编号。

一般用IP地址给设备进行编号，对于IPv4协议，IP地址共32位，分成了四段(比如192.168.100.1)，每段八位，只有一个单纯的IP地址虽然做到了区分设备，但是寻址起来十分麻烦，不可能去和全部设备一一匹配。

因此，IP地址有两种意义：

- 一个是网络号，负责标识该IP地址是属于哪个[子网]的
- 一个是主机号，负责标识同一[子网]下的不同主机

如何区分网络号和主机号？需要配合子网掩码才能计算出IP地址的 网络号 和 主机号

举个例子，比如 10.100.122.0/24，后面的`/24`表示就是 `255.255.255.0` 子网掩码，255.255.255.0 二进制是「11111111-11111111-11111111-00000000」，共 24 个1，为了简化子网掩码的表示，用/24代替255.255.255.0。

知道了子网掩码，该怎么计算出网络地址和主机地址呢？

将 10.100.122.2 和 255.255.255.0 进行**按位与运算**，就可以得到网络号，如下图：

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/16.jpg)

将 255.255.255.0 取反后与IP地址进行进行**按位与运算**，就可以得到主机号。

![子网掩码计算器](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E8%AE%A1%E7%AE%97%E5%99%A8.png)

在寻址过程中，先匹配到相同的网络号（表示要找到用一个子网），再去找对应的主机。

除了寻址能力，IP协议还有另一个重要的能力就是路由。两台设备并不是单纯通过一条网线连接起来的，而是通过很多网关、路由器、交换机等众多网络设备连接起来的，因此会形成很多条网络的路径。路由器寻址工作中，就是要找到目标地址的子网，进而把数据包转发给对应的网络。

IP协议的寻址作用是给予下一个目的地的方向，路由根据IP地址选择路径。寻址像导航、路由像操作方向盘。

![IP地址的网络号](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/17.jpg)

#### 1.1.4 网络接口层

网络层生成IP头部后，交给网络接口层（Link Layer），在IP头部前面加上MAC头部，并封装成数据帧（Date frame）发送到网络上

IP头部中的接收方IP地址表示网络包的目的地，通过这个地址可以判断把数据包发到哪里，但是在以太网的世界中，这个思路行不通

**以太网：**

电脑上的以太网接口，Wi-Fi接口，以太网交换机、路由器上的千兆，万兆以太网口，还有网线，它们都是以太网的组成部分。以太网就是一种在「局域网」内，把附近的设备连接起来，使它们之间可以进行通讯的技术。

以太网在判断网络包目的地时和IP的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而MAC头部正好起到该作用。所以要在以太网进行通讯要用到MAC地址。

MAC头部是以太网使用的头部，包含了接收方和发送方的MAC地址等信息，可以通过ARP协议获取对方的MAC地址。

网络接口层主要为网络层提供**链路级别**传输的服务，负责在以太网、WiFi这样的底层网络上发送原始数据包，工作在网卡这个层次，使用MAC地址，来标识网上的设备。



**总结：**

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/tcpip%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.drawio.png)

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png)

网络接口层的传输单位是帧（frame），IP层的传输单位是包（packet），TCP层的传输单位是段（segment），HTTP传输单位是消息或报文（message）。但这些没有本质的区分，统称为数据包。

### 1.2 键入网址到网页显示，期间发生了什么

#### 1.2.1 HTTP

![简单的网络模型](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/2.jpg)

1. 浏览器做的第一步工作就是对URL进行解析，从而生成发送给Web服务器的请求信息

   ![URL 解析](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/3.jpg)

   所以URL实际上是请求服务器里的文件资源。

   没有路径名时，就代表访问根目录下事先设置的默认文件，即/index.html或者/default.html

2. 对URL进行解析后，浏览器确定了Web服务器和文件名，接下来就是根据这些信息生成HTTP请求报文

   ![HTTP 的消息格式](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/4.jpg)

#### 1.2.2 DNS-真实地址查询

通过浏览器解析URL并生成HTTP报文后，需要委托操作系统将消息发给Web服务器。

但在发送之前，还有一项工作需要完成，即查询服务器域名对应的IP地址，因为委托操作系统发送消息时，必须提供通信对象的IP地址

打个比方，联系对方时，我们必须要知道对方的电话号码，但电话号码不方便记忆，因此将电话号码和联系人的姓名保存在通讯录中。

因此，有一种服务器专门保存了Web服务器域名与IP的对应关系，即DNS服务器

**域名的层级关系：**

DNS的域名用dot分割，例如www.server.com，这里的句点代表了不同层级之间的界限，在域名中，越靠右的位置表示层级越高。

实际上域名最后还有一个点，www.server.com. 最后一个点代表根域名，所以从上到下是，.跟域 -> .com顶级域 -> server.com，类似一个树状结构

![DNS 树状结构](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/5.jpg)

跟域的DNS服务器信息保存在互联网总所有的DNS服务器中，因此任何DNS服务器都可以找到并访问根域DNS服务器了。

所以客户端只要能找到任意一台DNS服务器，就可以通过它找到根域DNS服务器，然后再一路顺藤摸瓜找到位于下层的某台目标DNS服务器

**域名解析的工作流程：**

1. 客户端首先发出一个DNS请求，请求目标域名的IP地址，并发给本地DNS服务器（即客户端TCP/IP设置中填写的DNS服务器地址）
2. 本地域名服务器接收到客户端的请求后，如果缓存中的表格能找到域名，则直接返回其IP地址。如果没有，本地DNS就去询问其根域名服务器请求目标域名的IP地址，根域名服务器是最高层次的，不直接用于域名解析，但是能够指明方向
3. 根DNS收到来自本地DNS的请求后，发现后置是.com，归.com区域管理，因此返回.com顶级域名服务器地址
4. 本地DNS收到顶级域名服务器地址后，向顶级域名服务器询问目标域名的IP地址
5. 顶级域名服务器返回负责目标域名(www.server.com)的权威DNS服务器地址
6. 本地DNS于是转向权威DNS服务器，询问目标域名的IP地址，server.com的权威DNS服务器是域名解析结果的原出处。权威-我的域名我作主
7. 权威DNS服务器查询后将对应的IP地址X.X.X.X告诉给本地DNS
8. 本地DNS再将IP地址返回给客户端，客户端与目标建立连接

![域名解析的工作流程](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/6.jpg)

DNS域名解析过程只指路但不带路

并不是每次域名解析都要经过这样的过程，因为我们还有缓存

浏览器会先看自身有没有对当前目标域名的缓存（里面直接存着IP地址），如果有，直接返回，没有就去问操作系统，操作系统也会看自己的缓存，如果有也直接返回，没有再去hosts文件看，如果还没有，才回去问本地服务器。

所以流程大概是：浏览器缓存 -> 操作系统缓存 -> hosts文件

#### 1.2.3 协议栈-指南针

通过DNS获取到IP地址后，就可以把HTTP报文的传输工作交给操作系统中的协议栈。

协议栈内部分为几个部分，分别承担不同的工作。上下关系有一定规则，上面部分会向下面发布任务，下面部分接收到上面委托并执行

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/7.jpg)

应用程序（浏览器）通过调用Socket库，来委托协议栈工作。协议栈上半部分有两块，分别是负责收发数据的TCP和UDP协议，这两个传输协议会接受应用层的委托执行收发数据的操作。协议栈的下半部分用IP协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由IP负责的。

IP中还包括ICMP协议和ARP协议：

- ICMP用于告知网络包传输过程中产生的错误以及各种控制信息
- ARP用于根据IP地址查询相应的以太网MAC地址

IP下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡负责完成实际的收发操作，即对网线中的信号执行发送和接收操作

#### 1.2.4 TCP-可靠传输

HTTP是基于TCP协议传输的

**TCP包头格式：**

![TCP 包头格式](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/8.jpg)

- 源端口号和目标端口号是必不可少的，没有这两个端口号，数据就不知道应该从哪个应用发送到哪个应用

- 包的序号是为了解决包乱序的问题

- 确认序列是为了确认发出去对方是否有收到，如果没有收到就应该重新发送，直到送达，解决丢包问题

- 接下来是状态位:

  1. SYN：发起一个连接
  2. ACK：回复
  3. RST：重新连接
  4. FIN：结束连接

  TCO是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方状态的变更

- 窗口大小，TCP要做到流量控制，通信双方各声明一个窗口（缓存大小），标识自己当前能够处理数据包的能力，保证合适的发送速率，即别太快，也别太慢。除了做流量控制之外，TCP还会做拥塞控制，控制发送速度，尽量不让网络通路塞车

**TCP传输数据之前，要先三次握手建立连接**

在HTTP传输数据之前，首先要建立TCP连接，TCP连接的建立，通常称为三次握手。

所谓的连接，其实只是双方计算机里维护一个状态机，在建立连接的过程中，双方的状态变化时序图如果下图。

![TCP 三次握手](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png)

- 一开始，客户端和服务端都处于CLOSED状态。显示服务器主动监听某个端口，处于LISTEN状态
- 然后客户端主动发起连接SYN，之后处于SYN-SENT状态
- 服务端收到发起的连接，返回SYN，并且ACK客户端的SYN，之后处于SYN-RCVD状态
- 客户端收到服务端发送的SYN和ACK之后，发送对SYN确认的ACK，之后处于ESTABLISHED状态，因为它一发一收成功了
- 服务端收到ACK的ACK之后，处于ESTABLISHED状态，因为它也一发一收了

因此**三次握手的目的是保证双方都有发送和接收的能力**

**查看TCP的连接状态**

在Linux可以通过netstat -napt命令查看

![TCP 连接状态查看](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/10.jpg)

**TCP分割数据**

如果 HTTP 请求消息比较长，超过了 `MSS` 的长度，这时 TCP 就需要把 HTTP 的数据拆解成一块块的数据发送，而不是一次性发送所有数据。

![MTU 与 MSS](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/11.jpg)

- `MTU`：一个网络包的最大长度，以太网中一般为 `1500` 字节。
- `MSS`：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。

数据会被以 `MSS` 的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据加上 TCP 头信息，然后交给 IP 模块来发送数据。

![数据包分割](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/12.jpg)

**TCP报文生成**

TCP协议里面有两个端口，一个是浏览器监听的端口（通常是随机生成的），另一个是Web服务器监听的端口（HTTP默认端口号是80，HTTPS默认端口号是443）

在双方建立连接后，TCP报文中的数据部分就是存放HTTP头部+数据，组装好TCP报文之后，就需要交给下面的网络层处理

![TCP 层报文](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/13.jpg)

到此，数据包就有了TCP的保驾护航，但是仍不知道该往哪里走

#### 1.2.5 IP-远程定位

TCP模块在执行连接、收发、断开等各阶段操作时，都需要委托IP模块将数据封装成网络包发送给通信对象

IP报文头部格式：

![IP 包头格式](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/14.jpg)

- IP协议里需要有源地址IP（客户端输出的IP地址）和目标地址IP（通过DNS域名解析得到的Web服务器IP）
- 因为HTTP是经过TCP传输的，所以在IP包头的协议号，要填写为06（十六进制），表示协议为TCP

**假设客户端有多个网卡，就会有多个IP地址，那IP头部的源地址应该选择哪个IP**

当存在多个网卡时，在填写源地址IP时，需要判断应该填写哪个地址。这个判断相当于在多块网卡中判断应该使用哪个网卡来发送包

需要根据路由表规则来判断使用哪一个网卡来作为源地址IP

在Linux操作系统中，可以使用route -n指令来查看当前系统的路由表

![路由规则判断](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/16.jpg)

1. 首先先和第一条目的子网掩码（`Genmask`）进行 **与运算**，得到结果为 `192.168.10.0`，但是第一个条目的 `Destination` 是 `192.168.3.0`，两者不一致所以匹配失败。
2. 再与第二条目的子网掩码进行 **与运算**，得到的结果为 `192.168.10.0`，与第二条目的 `Destination 192.168.10.0` 匹配成功，所以将使用 `eth1` 网卡的 IP 地址作为 IP 包头的源地址。

那么假设 Web 服务器的目标地址是 `10.100.20.100`，那么依然依照上面的路由表规则判断，判断后的结果是和第三条目匹配。

第三条目比较特殊，它目标地址和子网掩码都是 `0.0.0.0`，这表示**默认网关**，如果其他所有条目都无法匹配，就会自动匹配这一行。并且后续就把包发给路由器，`Gateway` 即是路由器的 IP 地址。

**IP报文生成**

![IP 层报文](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/17.jpg)

至此，目的地已经知道了，但是太过遥远，数据包需要知道当前下一步应该去哪里

#### 1.2.6 MAC-两点传输

生成IP头部之后，接下来网络包还需要再IP头部前面加上MAC头部

**MAC包头格式**

MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息。

![MAC 包头格式](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/18.jpg)

在 MAC 包头里需要**发送方 MAC 地址**和**接收方目标 MAC 地址**，用于**两点之间的传输**。

一般在 TCP/IP 通信里，MAC 包头的**协议类型**只使用：

- `0800` ： IP 协议
- `0806` ： ARP 协议

**MAC发送方和接收方如何确认**

发送方的MAC地址比较简单，MAC地址是在网卡生产时写入到ROM里的，只要将这个值读取出来写入到MAC头部即可

接收方的MAC地址些许复杂，只要告诉以太网对方的MAC的地址，以太网就会帮我们把数据包发送过去，因此显然这里需要填写对方的MAC地址

所以先得搞清楚应该把包发给谁，这个只要查一下**路由表**就知道了。在路由表中找到相匹配的条目，然后把包发给 `Gateway` 列中的 IP 地址就可以了。



小插曲：在这里我一直有个疑惑，为什么有了IP地址还需要MAC地址？

解答：IP地址和MAC地址都是计算机网络中用于标识和定位设备的地址，但它们的作用不同。

IP地址是一种逻辑地址，用于标识网络中的设备和进行网络通信。在互联网中，每台设备都必须拥有一个唯一的IP地址，以便在网络中进行通信。

而MAC地址是一种物理地址，是指与网络接口卡（NIC）绑定的地址。在网络中，MAC地址用于在局域网中唯一标识设备。通过MAC地址，网络设备可以识别其他设备，并在局域网中进行通信。

因此，IP地址和MAC地址在网络中扮演不同的角色，IP地址用于进行网络通信，而MAC地址用于在局域网中唯一标识设备。尽管设备已经拥有IP地址，但在局域网中，MAC地址仍然是必需的，因为在局域网中，通信是通过MAC地址进行的。

总结：IP地址是在大范围互联网寻找相应子网的，而MAC地址用于小范围局域网找到对应设备



**如何获取对方的MAC地址**

需要ARP协议帮助我们找到路由器的MAC地址

![ARP 广播](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/19.jpg)

如果对方和自己处于同一个子网中，那么通过上面的操作就可以得到对方的 MAC 地址。然后，我们将这个 MAC 地址写入 MAC 头部，MAC 头部就完成了。

在后续操作系统会把本次查询结果放到一块叫做 **ARP 缓存**的内存空间留着以后用，不过缓存的时间就几分钟。

也就是说，在发包时：

- 先查询 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址。
- 而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 广播查询。

**查看ARP缓存内容**

在 Linux 系统中，我们可以使用 `arp -a` 命令来查看 ARP 缓存的内容。

![ARP 缓存内容](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/20.jpg)

**MAC报文生成**

![MAC 层报文](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/21.jpg)

至此，数据包已经知道自己下一步要去往哪里了，准备出发了。

#### 1.2.7 网卡-出口

网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，需要将数字信息转换为电信号，才能在网线上传输，这才是真正的数据发送过程

负责执行这一操作的是网卡，要控制网卡还需要靠网卡驱动程序

网卡驱动获取网络包之后，会将其复制到网卡内的缓存区中，接着会在其开头上加上报文和起始帧分界符，在末尾加上用于检测错误的帧校验序列。

![数据包](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E5%8C%85.drawio.png)

- 起始帧分界符是一个用来表示包起始位置的标记
- 末尾的 `FCS`（帧校验序列）用来检查包传输过程是否有损坏

#### 1.2.8 交换机-送别者

交换机的设计是将网络包原样转发到目的地。交换机工作在MAC层，也称为二层网络设备



**交换机的包接收操作**

1. 首先，电信号到达网线接口，交换机里的模块进行接收，接下来交换机里的模块将电信号转换为数字信号

2. 然后通过包末尾的FCS校验错误，如果没问题则放到缓冲区。这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同

3. 计算机的网卡本身具有MAC地址，并通过核对收到的包的接收方MAC地址判断是不是发给自己的，如果不是则丢弃。相对的，交换机的端口不核对接收方的MAC地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，交换机的端口不具有MAC地址

4. 将包存入缓冲区后，接下来需要查询一下这个包的接收方MAC地址是否已经在MAC地址表中已有记录

   交换机的 MAC 地址表主要包含两个信息：

   - 一个是设备的 MAC 地址，
   - 另一个是该设备连接在交换机的哪个端口上。

   ![交换机的 MAC 地址表](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/23.jpg)

   举个例子，如果收到的包的接收方 MAC 地址为 `00-02-B3-1C-9C-F9`，则与图中表中的第 3 行匹配，根据端口列的信息，可知这个地址位于 `3` 号端口上，然后就可以通过交换电路将包发送到相应的端口了。所以，**交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口**。



**当MAC地址表找不到指定的MAC地址时**

地址表中找不到指定的MAC地址，可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备一段时间没有工作导致地址被地址表删除了

此种情况下，交换机无法判断应该把包转发到哪个接口，只能将包转发到除了源端口之外的所有端口上，无论设备连接在哪个端口上都能接收到这个包

所以，**交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口**。

此外，如果接收方 MAC 地址是一个**广播地址**，那么交换机会将包发送到除源端口之外的所有端口。

以下两个属于广播地址：

- MAC 地址中的 `FF:FF:FF:FF:FF:FF`
- IP 地址中的 `255.255.255.255`

至此，数据包通过交换机抵达了路由器，准备离开土生土长的子网了。

#### 1.2.8 路由器-出境大门

**路由器与交换机的区别**

网络包经过交换机之后，到达了路由器，并在此被转发到了下一个路由器或目标设备。

这一步转发的工作原理和交换机相似，但还是有区别的

- 路由器是基于IP设计的，俗称三层网络设备，路由器的各个端口都具有MAC地址和IP地址
- 交换机是基于以太网设计的，俗称二层网络设备，交换机的端口不具有MAC地址



**路由器基本原理**

路由器的端口具有MAC地址，因此它能够成为以太网的发送方和接收方，同时还具有IP地址，从这个意义上来说，它和计算机的网卡是一样的

当转发包时，首先路由器端口会接收发给自己的以太网包，然后路由表查询转发目标，再由相应的端口作为发送方将以太网发送出去



**路由器的包接收操作**

1. 首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 `FCS` 进行错误校验。
2. 电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 `FCS` 进行错误校验。

总的来说，路由器的端口都具有 MAC 地址，只接收与自身地址匹配的包，遇到不匹配的包则直接丢弃。

和交换机的包接收类似



完成包接收操作之后，路由器就会**去掉**包开头的 MAC 头部。

**MAC 头部的作用就是将包送达路由器**，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会**被丢弃**。

接下来，路由器会根据 MAC 头部后方的 `IP` 头部中的内容进行包的转发操作。



转发操作分为几个阶段，首先是查询**路由表**判断转发目标。

![路由器转发](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/24.jpg)

假设地址为 `10.10.1.101` 的计算机要向地址为 `192.168.1.100` 的服务器发送一个包，这个包先到达图中的路由器。

判断转发目标的第一步，就是根据包的接收方 IP 地址查询路由表中的目标地址栏，以找到相匹配的记录。

路由匹配和前面讲的一样，每个条目的子网掩码和 `192.168.1.100` IP 做 **& 与运算**后，得到的结果与对应条目的目标地址进行匹配，如果匹配就会作为候选转发目标，如果不匹配就继续与下个条目进行路由匹配。

如第二条目的子网掩码 `255.255.255.0` 与 `192.168.1.100` IP 做 **& 与运算**后，得到结果是 `192.168.1.0` ，这与第二条目的目标地址 `192.168.1.0` 匹配，该第二条目记录就会被作为转发目标。

实在找不到匹配路由时，就会选择**默认路由**，路由表中子网掩码为 `0.0.0.0` 的记录表示「默认路由」。



**路由器的发送操作**

接下来就会进入包的**发送操作**。

首先，我们需要根据**路由表的网关列**判断对方的地址。

- 如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，**还未抵达终点**，还需继续需要路由器转发。
- 如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明**已抵达终点**。

知道对方的 IP 地址之后，接下来需要通过 `ARP` 协议根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址。

路由器也有 ARP 缓存，因此首先会在 ARP 缓存中查询，如果找不到则发送 ARP 查询请求。

接下来是发送方 MAC 地址字段，这里填写输出端口的 MAC 地址。还有一个以太类型字段，填写 `0800` （十六进制）表示 IP 协议。

网络包完成后，接下来会将其转换成电信号并通过端口发送出去。这一步的工作过程和计算机也是相同的。

发送出去的网络包会通过**交换机**到达下一个路由器。由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。

接下来，下一个路由器会将包转发给再下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。

不知你发现了没有，在网络包传输的过程中，**源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址**，因为需要 MAC 地址在以太网内进行**两个设备**之间的包传输。

#### 1.2.9 服务器与客户段

![网络分层模型](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/25.jpg)

数据包抵达服务器后，服务器就会先扒开数据包的MAC头部，查看是否和服务器自己的MAC地址符合，符合就接收包

接着继续扒开数据包的 IP 头，发现 IP 地址符合，根据 IP 头中协议项，知道自己上层是 TCP 协议。

于是，扒开 TCP 的头，里面有序列号，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。TCP 头部里面还有端口号， HTTP 的服务器正在监听这个端口号。

于是，服务器自然就知道是 HTTP 进程想要这个包，于是就将包发给 HTTP 进程。

服务器的 HTTP 进程看到，原来这个请求是要访问一个页面，于是就把这个网页封装在 HTTP 响应报文里。

HTTP 响应报文也需要穿上 TCP、IP、MAC 头部，不过这次是源地址是服务器 IP 地址，目的地址是客户端 IP 地址。

穿好头部衣服后，从网卡出去，交由交换机转发到出城的路由器，路由器就把响应数据包发到了下一个路由器，就这样跳啊跳。

最后跳到了客户端的城门把守的路由器，路由器扒开 IP 头部发现是要找城内的人，于是又把包发给了城内的交换机，再由交换机转发到客户端。

客户端收到了服务器的响应数据包后，同样也非常的高兴，客户能拆快递了！

于是，客户端开始扒皮，把收到的数据包的皮扒剩 HTTP 响应报文后，交给浏览器去渲染页面，一份特别的数据包快递，就这样显示出来了！

最后，客户端要离开了，向服务器发起了 TCP 四次挥手，至此双方的连接就断开了。



交换机：可以简单理解成一个设备，三台电脑通过网线连接到这台设备，这三台电脑就可以互相通信了，交换数据

Mac 地址只能是两个设备之间传递时使用的，如果你要从大老远给我发消息，是离不开 IP 地址的。
